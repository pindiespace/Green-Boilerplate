<?php

/** 
 * @class GBP_BOOTSTRAP bootstrapper sniffs user agent, builds core GBP JavaScript object
 * adaptative feature detection driven by server-side browser sniffing
 *
 * PHP optimizations guided by benchmarks at:
 * http://www.phpbench.com/
 *
 */
 
 
/**
 * LOAD BASE CLASS
 * always load our base class relative to our current working directory
 */ 
$curr_dir = dirname(__FILE__);
require_once($curr_dir.'/gbp.php');
require_once($curr_dir.'/gbp-analyze.php');

/** 
 * LOAD GBP BOOTSTRAP
 */
class GBP_BOOTSTRAP extends GBP {

	
	/** 
	 * constants that correspond to JavaScript keywords 
	 * in variable
	 * @static
	 */
	static private $HELPER                 = 'helper';     //helper object (not a real component in the database)S
	
	/**
	 * placeholder property values for dynamic PHP or other functions 
	 * that are executed on the server side
	 */
	static private $DETECTOR_SERVER_PHP    = 'server-php';    //php server-side detector class
	static private $DETECTOR_SERVER_PYTHON = 'server-python'; //python server-side script
	static private $DETECTOR_SERVER_JS     = 'server-js';     //node.js, rhino
	static private $DETECTOR_SERVER_CSHARP = 'server-csharp'; //csharp program
	static private $DETECTOR_SERVER_RUBY   = 'server-ruby';   //ruby program (command-line)

	/**
	 * directory paths
	 * @static
	 */
	 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//AN INCLUDE FOR BOOTSTRAP AND COMPILE?
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	

	 
	static private $GBP_SERVER_PY_PROPS = ''; //contains all detector values returned by a Python script
	
	
	
	/** 
	 * DEBUG variables
	 */
	static private $DEBUG_db_properties;
	static private $DEBUG_server_properties;
	

	public function __construct () 
	{
		error_reporting(E_ALL | E_STRICT);

		parent::__construct();
		
		/** 
		 * path to server-side libraries for dynamic server-side properties (e.g. hostname)
		 */
		self::$GBP_SERVER_DIR     = self::$GBP_DB_DIR.'server/';
		self::$GBP_SERVER_PHP_DIR = self::$GBP_SERVER_DIR.'php/';   //php
		self::$GBP_SERVER_PY_DIR  = self::$GBP_SERVER_DIR.'py/';    //python
		self::$GBP_SERVER_RB_DIR  = self::$GBP_SERVER_DIR.'rb/';    //ruby

		/** 
		 * path to server-side JS polyfills
		 */
		self::$GBP_SERVER_LIB_JS_DIR = self::$GBP_LIB_DIR.'js/';  //javascript
		
		/** 
		 * load our server-side PHP objects
		 * GBP class with server-side detectors
		 */
		$php_fl = self::$GBP_SERVER_PHP_DIR.self::$GBP_SERVER_PHP_FNS_FILE;
		if(file_exists($php_fl))
		{
			require_once($php_fl);
		}
		
		/** 
		 * write GPB JavaScript object to output
		 */
		self::write_gbp();
		
		/* 
		 * if we have debug data, generated by gbp-bootstrap (e.g. 
		 * whether we used a detector function or a client-version 
		 * database value) print it is a separate script
		 */
		if(self::$DEBUG) 
		{
			self::print_debug_js();
		}
		
	}
	


	/**  
	 * --------------------------------------------------------- 
	 * @method check_if_quotes_needed
	 * given a property, see if we need to 
	 * surround it with quotes for it to function 
	 * in JavaScript.
	 * NOTE: we also add this method into the server-side 
	 * PHP detector object called later by gbp-bootstrap.php
	 * for dynamic detections on the server at runtime.
	 * 
	 * For the client-side, detector functions are written so that they 
	 * can't return values that will crash as object values in JS.
	 *
	 * Properties are surrounded with double-quotes
	 * @param {String} $prop the property value
	 * @returns {String} the property value, decorated with quotes
	 * --------------------------------------------------------- 
	 */
	private function check_if_quotes_needed ($prop)
	{
		if(!isset($prop))
		{
			self::$ERROR[__METHOD__][] = "check_if_quotes_needed() INVALID property value";
			return self::$UNDEFINED;	
		}
		
		/** 
		 * test property depending on datatype
		 */
		switch($prop)
		{
			/** 
			 * we don't need quotes around these JS keywords
			 */
			case self::$TRUE:
			case self::$FALSE:
			case self::$UNDEFINED:
			case self::$NULL:
				break;
			
			default:
				if(strpos($prop, 'function') !== false)
				{
					self::$ERROR[__METHOD__][] = "check_if_quotes_needed() FUNCTION supplied for check:$prop";
				}
				
				
				if(!is_numeric($prop))
				{
					$prop = '"'.$prop.'"';	
				}
				else
				{
					/** 
					 * very large numbers (e.g. 23904280493832098402934202948230432980)
					 * are OK in JavaScript, as the interpreters convert them to 
					 * power notation. However, we put a warning, since a number written in 
					 * this way may be an error. Tokens or keys with are large sets of numeric 
					 * symbols are extremely unlikely to be defined in the database.
					 */
					 if(strlen($prop) > 29)
					 {
						 self::$ERROR[__METHOD__][] = "Property value error - number is too large or small";
					 }
						
				}
				break;
		}
		return $prop;
	}
	
	
	/** 
	 * --------------------------------------------------------- 
	 * @method run_server_script
	 * run a non-PHP server script from PHP (assuming we are on a Unix-type server)
	 * @param {String} $scr_file path to script or .exe file
	 * @param {String|false} $interpreter name of interpreter (php, python, perl, ruby)
	 * @param {Boolean} $stored_results 
	 * 
	 * References:
	 * http://stackoverflow.com/questions/4619996/how-to-run-ruby-python-scripts-from-inside-php-passing-and-receiving-parameters
	 * http://molecularsciences.org/PHP/proc_open_tutorial_and_examples
	 * --------------------------------------------------------- 
	 */
	private function run_server_script($scr_file, $prop_args, $interpreter=false)
	{
		if($interpreter === false)
		{
			/** 
			 * this is a path to the script only
			 */
			if(!file_exists($scr_file))
			{
				if(self::$DEBUG === true) self::$ERROR[__METHOD__][] = "$interpreter File Not found";
				return false;
			}
		}

		else
		{
			/** 
			 * make executable string, appending the 
			 * interpreter command on the system. This handles
			 * cases where the exe environment needs something like 
			 * python myfile.py
			 * ...and writing #!/usr/bin/env python myfile.py
			 * at the top of the script file doesn't work
			 *
			 * on Media Templ GS, Perl works with the first 
			 * method, but Python needs the second method
			 */
			$scr_file = $interpreter.' '.$scr_file;
		}
		
		$args_str = implode(" ",$prop_args);
		
		$process = proc_open($scr_file.' '.$args_str, array( 
			0 => array('pipe','r'),        //stdin values
			1 => array('pipe','w'),        //output pipe for script
			2 => array('pipe','w')),       //error output pipe
			$pipes);
		
		if (is_resource($process)) 
		{
			
			/** 
			 * if we have arguments to our stdin input, input them
			 * fwrite($pipes[0], 'hello world');
			 */
			fclose($pipes[0]);

			$output = stream_get_contents($pipes[1]);
			$error  = stream_get_contents($pipes[2]);
				
			if(self::$DEBUG === true) self::$ERROR[__METHOD__][] = "proc_open error: $error";
				
			fclose($pipes[1]);
			fclose($pipes[2]);

			//close pipes before calling proc_close to avoid a deadlock
			
			$return_value = proc_close($process);

			if(self::$DEBUG === true) self::$ERROR[__METHOD__][] = "command returned:$return_value";
			if(self::$DEBUG === true && strlen($error) > 0) self::$ERROR[__METHOD__][] = "error: $error";
			
			/** 
			 * all non-PHP scripts MUST return output as a JSON string
			 */
			return json_decode($output, true);
		}
		else
		{
			if(self::$DEBUG === true) self::$ERROR[__METHOD__][] = "not a resource<br>";
		}
			
		
		return false;
	}
	
	
	
	/** 
	 * =========================================================
	 * CREATE GBP OBJECT
	 * =========================================================
	 */
	
	
	/**
	 * ---------------------------------------------------------  
	 * db_get_properties
	 * get all the defined properties for this install, and decode 
	 * to an associative array
	 * @returns {Array} a PHP array with the data for a client strored in the GBP 
	 * database array
	 * --------------------------------------------------------- 
	 */
	public function db_get_properties () 
	{
		return json_decode(file_get_contents(self::$GBP_CLIENT_JS_DIR.self::$GBP_BROWSER_PROPERTIES_FILE), true);	
	}
	
	
	/** 
	 * --------------------------------------------------------- 
	 * @method db_get_config_properties
	 * get GBP configuration properties set at installation
	 * TODO:
	 * TODO: figure out how to get GBP config properties
	 * TODO:
	 * --------------------------------------------------------- 
	 */
	public function db_get_config_properties ()
	{
		self::$stats_arr[] = "WARNING: db_get_config_properties not complete";
	}
	
	
	/** 
	 * --------------------------------------------------------- 
	 * @method get_client_version
	 * scanning user-agent and other http headers, 
	 * return the client name and version for matching 
	 * in the database.
	 * @returns {Array} the client_version array with information 
	 * about the particular client and version (e.g. IE8)
	 * TODO:
	 * TODO: incomplete - we aren't loading our user-agent detector yet
	 * TODO:
	 * --------------------------------------------------------- 
	 */
	public function get_client_version ()
	{
		
		$gbp_analyze = new GBP_ANALYZE;
		
		$client_version_arr = $gbp_analyze->get_client($_SERVER['HTTP_USER_AGENT']);
		
		/*
		//FAKE A RETURN 
		//Position 0 is the client name
		//Position 1 is the client version number
		$client_version_arr = array('firefox',
				'2.0');
		//convert version number to GBP standard
		$client_version_arr[1] = self::generate_php_version_key($client_version_arr[1]);
		*/
		
		return $client_version_arr;
	}
	
		
	/** 
	 * --------------------------------------------------------- 
	 * @method get_client_data
	 * get information about the client from the GBP database
	 * requires a scan through the user-agent via get_client_version to work
	 * @returns {Array} PHP array with client_version data
	 * --------------------------------------------------------- 
	 */
	public function db_get_client_version_properties ()
	{
		$client_version_arr = self::get_client_version();
		
		if(is_array($client_version_arr) && is_file(self::$GBP_CLIENT_JS_DIR.$client_version_arr[0].'.php')) 
		{
			$client_version_db = json_decode(file_get_contents(self::$GBP_CLIENT_JS_DIR.$client_version_arr[0].'.php'), true);
		}
		
		/** 
		 * get the max allowed rounding down allowed when scanning for a 
		 * version. For example, if we have a version 35.01, which was 
		 * translated to 3501, then check the allowed round down by 
		 * multiply cutoff * multiplier. Check the integer, and if 
		 * the difference is allowd, round down
		 */
		$round_down = self::$VERSION_CUTOFF * self::$MULTIPLIER;
		$rounded = intval(round($client_version_arr[1]/self::$MULTIPLIER) * 100);
		
		//echo "round_down:$round_down, version:".$client_version_arr[1].", rounded:$rounded<br>";
		//print_r($client_version_db[$rounded]);
		
		//if($client_version_arr[1] - $rounded < $round_down)
		
		if(isset($client_version_db[$client_version_arr[1]]))
		{
			//return just the client-version database, as a PHP array
			
			return $client_version_db[$client_version_arr[1]];
		}
		else if(isset($client_version_db[$rounded]))
		{
			return $client_version_db[$rounded];
		}
		
		//did not find any database record for this client-version
		
		return false;
		
	}
	
	
	/** 
	 * ========================================================= 
	 * Output the GBP JS object
	 * ========================================================= 
	 */


	/**
	 * ---------------------------------------------------------  
	 * @method build_gbp_head
	 * incorporate JS polyfills
	 * build the start of the GBP object
	 * @returns {String} string corresponding to the beginning 
	 * of the GBP JS object
	 * --------------------------------------------------------- 
	 */
	private function build_gbp_head ()
	{
		//console.log polyfill
		
		include(self::$GBP_SERVER_LIB_JS_DIR.'consolelog.js');
		
		//more polyfills
		
		//return the beginning of GBP
		
		return "<script>\nvar ".self::$GBP." = (function () {\n\n";
	}
	
	
	/** 
	 * --------------------------------------------------------- 
	 * @method build_gbp_foot
	 * finish construction the GBP JS object
	 * @returns {String} string corresponding to the entire GBP 
	 * JavaScript object, to be inserted in the document head
	 * --------------------------------------------------------- 
	 */
	private function build_gbp_foot ($run)
	{
		/** 
		 * build the "run" function and end of constructor function
		 */ 
		return "$run\n\n})(); //end of ".self::$GBP."\n\n</script>\n";    
	}


	/** 
	 * --------------------------------------------------------- 
	 * @method build_gpb
	 * build the GBP JS object, filling in: 
	 * - server-side data
	 * - data uploaded in HTTP headers
	 * - data uploaded in HTTP client cookie
	 * results are ECHOed to output, inserting the 
	 * GBP JS object directly into the markup
	 * --------------------------------------------------------- 
	 */
	private function build_gbp ()
	{
		//get the list of all properties
		
		$full_properties = self::db_get_properties();
		
		if(isset($full_properties['debug']) && $full_properties['debug'])
		{
			self::$DEBUG = $full_properties['debug'];
		}
		
		/** 
		 * get the subset of properties defined in the GBP client database, 
		 * if the client was discovered and the client-version database has data
		 */
		$client_version_db = self::db_get_client_version_properties();
		
		/** 
		 * create the GBP head script (e.g. polyfills, preloaders)
		 */
		echo self::build_gbp_head();
		
		/** 
		 * using our PHP detector class, create PHP dynamic, server-side 
		 * detection methods, and get the list of method names
		 * that are present (varies with build)
		 * NOTE:
		 * read method (detector) list with get_class_methods()
		 */
		$server_php = new GBP_SERVER_PHP_DETECTORS;
				
		/** 
		 * check if we have a Python server-side program, and execute if present
		 * TODO: have a list of Pythonic functions we can try to executed, and only 
		 * execute those. For example, if we don't want to geoloacate, and Python has 
		 * geolocation, DON'T DO IT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 * TODO:
		 * TODO:
		 * TODO:
		 */
		$fn = array();
		//TODO: PUT PARAMETER LIST INTO THIS!!!!!!
		//TODO:
		$scr = self::$GBP_SERVER_PY_DIR.self::$GBP_SERVER_PY_FNS_FILE;
		self::$GBP_SERVER_PY_PROPS = self::run_server_script($scr, $fn, 'python');
		
		/** 
		 * At this point, all server detectors have run
		 * loop through the list of components, with their attached properties
		 * TODO: 
		 * TODO: convert to FASTER FORMAT
		 * echo 'something and more' , $i , $i+100 , 'something else and then some';
		 */
		foreach($full_properties as $component_key => &$component)
		{
			/** 
			 * we passed the js_exe_arr as a run() 
			 * functions executing non-helper functions 
			 * which rewrite themselves as properties
			 */
			if($component_key == 'js_exe_arr')
			{
				$js_exe_arr = $component;
			}
			else if($component_key == 'debug')
			{
				self::$DEBUG = $component;
				self::$stats_arr['debug'][] = 'Updated DEBUG of bootstrap to '.$component.' using compiler flag';
			}
			else {
			
				echo "\tvar $component_key = {\n";
				/** 
				 * loop through the list of properties
				 * for a given component
				 */
				$len = count($component);
				$n = 0;
				foreach($component as $property_key => &$property)
				{
					$n++; //increment our 'comma counter' loop
					
					switch($property)
					{
						case self::$TRUE:
						case self::$FALSE:
						case self::$NULL:
							/** 
							 * unusual, since this would imply that the property had 
							 * an always-defined value, rather than one that varied with 
							 * the client database. GBP.config may have values like this
							 */
							break;
							
						case self::$UNDEFINED:
							/** 
							 * we don't have a property, and no detector, since our $property 
							 * is 'undefined' and not a detector function. 
							 * check the property, and if it is in the database, 
							 * check if it also needs surrounding quotes. No quotes 
							 * for functions, true, false, undefined
							 */
							if(isset($client_version_db[$component_key][$property_key]))
							{
								$property_db = $client_version_db[$component_key][$property_key];
								$property = $property_db;
								
								/**
								 * check if we need to surround the property we got from the 
								 * initializr database with quotes, add if needed
								 */
								$property = self::check_if_quotes_needed($property_db); //TODO: SHOULD BE DONE ENTIRELY IN THE COMPILER!!!!!!!
									
								//record debug data
									
								if(self::$DEBUG)
								{
									self::$DEBUG_db_properties[$component_key][$property_key] = $property;
								}
									
							}
							break;
					
						default: 
							/** 
							 * process server detector functions in different languages
							 * we CANNOT have an entry in the client database ($client_version_db) 
							 * for a PHP or Python-derived property, so we don't need to check it.
							 *
							 * we assume that the default property value will ALWAYS be a function 
							 * detector, written out as a string (so we can't
							 * have an Array as a property value)
							 */
							if(strpos($property, self::$DETECTOR_SERVER_PHP) !== false)
							{
								/* 
								 * get the name of the property, which is also the detector method 
								 * used to get the property from the $server_php object
								 */
								$fn = $property_key;
							
								/** 
								 * see if the property value coming back from the PHP detector method 
								 * needs to be quoted to work properly in JS, and 
								 * add quotes if needed
								 * 
								 * TODO:
								 * TODO: add quotes in the compiler?
								 * TODO:
								 */
								$property = self::check_if_quotes_needed($server_php->$fn());
								
								//record debug data
								
								if(self::$DEBUG)
								{
									self::$DEBUG_server_properties[$component_key][$property_key] = $property;
								}
							}
							else if(strpos($property, self::$DETECTOR_SERVER_PYTHON) !== false)
							{
								/* 
								 * Run a Python server-side detector script
								 */
								if(is_array(self::$GBP_SERVER_PY_PROPS))
								{
									//TODO: add the quotes in the complier?
									//TODO:
									//TODO:
									$property = self::check_if_quotes_needed(self::$GBP_SERVER_PY_PROPS[$property_key]);
									
									//record debug data
									
									if(self::$DEBUG)
									{
										self::$DEBUG_server_properties[$component_key][$property_key] = $property;
									}
								}
							
							}
							else 
							{
								/** 
								 * 1. client-side JavaScript functions, which pass through to the client
								 *    no-action need be taken.
								 * 
								 * 2. properties whose value was unknown until we loaded $client_version_db
								 *    so, we had "function" in the compiler, but now we have a simple value
								 *    so wrap the database value in a self-rewriting function
								 */
								
								
								
								if(isset($client_version_db[$component_key][$property_key]))
								{
									$property_db = $client_version_db[$component_key][$property_key];
									
									$property = self::check_if_quotes_needed($property_db); //TODO: SHOULD BE DONE ENTIRELY IN THE COMPILER!!!!!!!
									
									//$property = "function () { return this.$property_key = $property_db; }";
										
									//record debug data
										
									if(self::$DEBUG)
									{
										self::$DEBUG_db_properties[$component_key][$property_key] = $property_db;
									}
								
								}
								
								
								
								
								
							
							}
							break;
				
				}
				
				/** 
				 * write to performance object
				 * TODO:
				 * TODO: SPEED PROBLEM?????????s
				 * TODO: 
				 */
				
				if($component_key == 'performance')
				{
					if($property_key == 'servertime')
					{
						//over-write property
						$property = intval((self::microtime_float() - self::$stats_arr['build_start']) * 1000);
						if(self::$DEBUG)
						{
							self::$DEBUG_server_properties[$component_key][$property_key] = $property;
						}
					}
				}

				
				
				/** 
				 * write the final GBP property into the component sub-object, either undefined, a 
				 * simple value, or a JS detector function.
				 * remove the trailing comma for the last member of the object (IE6-8 compatibility)
				 */
				echo "\t\t".$property_key." : ".$property;//.",\n"; 
				if($n < $len)
				{
					echo ",\n";
				}
				else
				{
					echo "\n";
				}
				
			} //end of property list for a given component
			
			echo "\n\t};\n\n";
			
			} //end of else for component not js_exe_array
			
		} //end of loop through all components
		
		
		echo self::build_gbp_foot($js_exe_arr);
		
		
		//TODO: add in config
		
		//TODO: add in returned from client-side (headers, cookies $_COOKIE)
		
		
	}
	 
	
	/** 
	 * --------------------------------------------------------- 
	 * @write_minimal_gbp
	 * if our browser doesn't support JavaScript 1.5 (no try...catch)
	 * or DOM 1, write a minimal GBP object
	 * TODO:
	 * TODO: incomplete
	 * TODO: 
	 * --------------------------------------------------------- 
	 */
	private function write_minimal_gbp ()
	{
		self::$stats_arr[] = "WARNING: write_minimal_gbp not complete";
	}
	
	
	/** 
	 * --------------------------------------------------------- 
	 * @write_gbp
	 * wrapper for build_gbp
	 * write GBP JavaScript (1.5 or higher) object to output
	 * --------------------------------------------------------- 
	 */
	private function write_gbp ()
	{	
		/** 
		 * start performance timer
		 */
		self::$stats_arr['build_start'] = self::microtime_float();
		self::$stats_arr['build_end']   = 0;

		self::build_gbp();                     //build GBP
		
		/** 
		 * end performance timer
		 */
		self::$stats_arr['build_end'] = self::microtime_float();
		self::$stats_arr['build_time'] = intval((self::$stats_arr['build_end'] - self::$stats_arr['build_start']) * 1000)." msec";

	}
	

	/** 
	 * ========================================================= 
	 * RENDERING AND OUTPUT FUNCTIONS
	 * ========================================================= 
	 */
	 
	
	/** 
	 * if $DEBUG is set to true, we will have arrays listing
	 * property values from the client-version database, and 
	 * server-side PHP, Python... detectors. This method converts 
	 * the arrays to separate JS objects that can be used in debugging
	 * 
	 * They are different from the array listing detector type, which is 
	 * generated in the compiler, and inserted into the run() function in GBP
	 * TODO: 
	 * TODO: write this detector type array as a separate function as well
	 * TODO:
	 */
	public function print_debug_js()
	{
		echo "\n<script>\n";
		echo "var debug_db_properties = ".json_encode(self::$DEBUG_db_properties).";\n";
		echo "\n";
		echo "var debug_server_properties =".json_encode(self::$DEBUG_server_properties).";\n";
		echo "\n";
		echo "</script>\n";
	}



}; //end of class


/** 
 * create GBP object
 */
$bootstrap = new GBP_BOOTSTRAP();